# Стратегия

> Паттерн **стратегия** определяет семейство алгоритмов, инкапсулирует их и обеспечивает их взаимозаменяемость. Он позволяет модифицировать алгоритмы независимо от их использования на стороне клиента. 

Вот такое определение дается этому паттерну в книге "Паттерны проектирования".

Стратегия нужна тогда, когда нужно не просто спрятать алгоритм, а когда нам важно иметь возможность заменить его во время исполнения.

## Описание примера, на котором будем тренироваться

На словах, думаю, не совсем понятно то, как работает этот паттерн. Поэтому давайте разберем пример простого приложения.

Мы сделаем простое приложение, где будут персонажи и они будут драться с помощью оружия. 

#### Персонажи

Пусть у нас будет король, королева и тролль.

#### Оружие

В арсенале оружия у нас будет нож, меч и топор.

Каждый персонаж может владеть любым из этих оружий. И использовать его, чтобы драться.

![](http://storage9.static.itmages.com/i/14/1118/h_1416322069_9959895_dc4988faec.png)

### Подумаем о персонажах

Итак, давайте определимся, что умеют делать персонажи и что у них есть. У персонажей есть оружие (но его может и не быть). Персонаж может сказать кто он и нанести удар.

Также персонаж может менять свое оружие. Давайте быстро спроектируем абстрактный класс для персонажа.

![](http://storage8.static.itmages.com/i/14/1118/h_1416322688_9354164_cc8ac4c02b.png)

В `_weapon` у нас будет храниться оружие персонажа, а сеттер `weapon` будет отвечать за присвоение оружия персонажу.

В методе (который будет *абстрактным*) `say()` персонаж будет говорить, кто он такой, а в методе `fight()` - наносить удар.

Все три персонажа будут наследниками этого абстрактного класса. 

![](http://storage8.static.itmages.com/i/14/1118/h_1416323153_1928329_d16f43da2a.png)

### Подумаем об оружии

Персонажи могут менять оружие, поэтому, будет правильно, если мы определим общий интерфейс для работы с оружием. Назовем этот интерфейс `WeaponBehavior`. Наши персонажи могут только использовать оружие, поэтому интерфейс будет требовать реализации только одного метода - `useWeapon()`, который нужно будет реализовать каждому виду оружия.

Выделив общий интерфейс для оружия мы позволим достаточно просто реализовать замену оружия так, что нашим персонажам будет все равно, что они используют. Они будут просто вызывать метод `useWeapon()`.

Давайте взглянем на наш интерфейс оружия: 

![](http://storage6.static.itmages.com/i/14/1118/h_1416323871_2345869_73719bb66f.png) 

Классы ножа, меча и топора будут реализовывать этот интерфейс. В нашем случае, они просто будут содержать реализацию метода `useWeapon()`.

Вот как будет выглядеть связь:

![](http://storage5.static.itmages.com/i/14/1118/h_1416324163_6758001_13beaf8823.png)

### Что мы имеем

Сейчас мы спроектировали такую архитектуру, где персонаж будет просто знать о том, что в руках у него есть оружие, но какое именно оружие он не знает. Он знает, что его можно использовать. Как использовать конкретное оружие уже определяется в самом оружии. 

Такая архитектура нам позволяет без проблем создавать новое оружие и сразу же начинать его использовать. Вот как будет выглядеть архитектура в целом:

![](http://storage8.static.itmages.com/i/14/1118/h_1416324523_3562306_70a3b86fc0.png)