# Стратегия

> Паттерн **стратегия** определяет семейство алгоритмов, инкапсулирует их и обеспечивает их взаимозаменяемость. Он позволяет модифицировать алгоритмы независимо от их использования на стороне клиента. 

Вот такое определение дается этому паттерну в книге "Паттерны проектирования".

Стратегия нужна тогда, когда нужно не просто спрятать алгоритм, а когда нам важно иметь возможность заменить его во время исполнения.

## Описание примера, на котором будем тренироваться

На словах, думаю, не совсем понятно то, как работает этот паттерн. Поэтому давайте разберем пример простого приложения.

Мы сделаем простое приложение, где будут персонажи (король, королева и тролль) и они будут драться с помощью оружия. 

В арсенале оружия у нас будет нож, меч и топор.

Каждый персонаж может владеть любым из этих оружий. И использовать его, чтобы драться.

![](http://storage9.static.itmages.com/i/14/1118/h_1416322069_9959895_dc4988faec.png)

### Подумаем о персонажах

Итак, давайте определимся, что умеют делать персонажи и что у них есть. У персонажей есть оружие (но его может и не быть). Персонаж может сказать кто он и нанести удар.

Также персонаж может менять свое оружие. Давайте быстро спроектируем абстрактный класс для персонажа.

![](http://storage8.static.itmages.com/i/14/1118/h_1416322688_9354164_cc8ac4c02b.png)

В `_weapon` у нас будет храниться оружие персонажа, а сеттер `weapon` будет отвечать за присвоение оружия персонажу.

В методе (который будет *абстрактным*) `say()` персонаж будет говорить, кто он такой, а в методе `fight()` - наносить удар.

Все три персонажа будут наследниками этого абстрактного класса. 

![](http://storage8.static.itmages.com/i/14/1118/h_1416323153_1928329_d16f43da2a.png)

### Подумаем об оружии

Персонажи могут менять оружие, поэтому, будет правильно, если мы определим общий интерфейс для работы с оружием. Назовем этот интерфейс `WeaponBehavior`. Наши персонажи могут только использовать оружие, поэтому интерфейс будет требовать реализации только одного метода - `useWeapon()`, который нужно будет реализовать каждому виду оружия.

Выделив общий интерфейс для оружия мы позволим достаточно просто реализовать замену оружия так, что нашим персонажам будет все равно, что они используют. Они будут просто вызывать метод `useWeapon()`.

Давайте взглянем на наш интерфейс оружия: 

![](http://storage6.static.itmages.com/i/14/1118/h_1416323871_2345869_73719bb66f.png) 

Классы ножа, меча и топора будут реализовывать этот интерфейс. В нашем случае, они просто будут содержать реализацию метода `useWeapon()`.

Вот как будет выглядеть связь:

![](http://storage5.static.itmages.com/i/14/1118/h_1416324163_6758001_13beaf8823.png)

### Что мы имеем

Сейчас мы спроектировали такую архитектуру, где персонаж будет просто знать о том, что в руках у него есть оружие, но какое именно оружие он не знает. Он знает, что его можно использовать. Как использовать конкретное оружие уже определяется в самом оружии. 

Такая архитектура нам позволяет без проблем создавать новое оружие и сразу же начинать его использовать. Вот как будет выглядеть архитектура в целом:

![](http://storage8.static.itmages.com/i/14/1118/h_1416324523_3562306_70a3b86fc0.png)

## Давайте начнем писать код

Первым делом создадим файл `pubspec.yaml`, в котором укажем имя нашего приложения (пусть это будет `game`):

```yaml
name: game
```

Создадим папку `bin`, а в ней файл `game.dart`, в котором пропишем пока что пустую функцию `main()`:

```dart
main() {
	
}
```

Теперь создадим папку `lib`, в которой будут находиться классы персонажей и оружия нашего приложения. Добавим в нее файл `game.dart`, в котором объявим библиотеку `game`.

```dart
library game;
```

### Создание оружия

Итак, базовую структуру мы сделали, давайте теперь перейдем к оружию.

Создадим внутри папке `lib`, папку `weapon`, в которой будет находиться интерфейс для определения поведения оружия и сами классы оружия.

В Dart классы являются одновременно и интерфейсами. Давайте создадим интерфейс `WeaponBehavior` (файл `lib/weapon/weapon_behavior.dart`).

```dart
part of game;

abstract class WeaponBehavior {

  void useWeapon();

}
```

В первой строке мы указали, что данный файл является частью библиотеки `game`, затем объявили абстрактный класс `WeaponBehavior` (который будем использовать как интерфейс), а в нем метод `useWeapon()`.

Все, интерфейс готов. Подключим его теперь к нашей библиотеке с помощью ключевого слова `part` в файле `lib/game.dart`.

```dart
library game;

part "src/weapon/weapon_behavior.dart";
```

#### Теперь создадим классы оружия для ножа, меча и топора, которые будут реализовывать интерфейс `WeaponBehavior`

Начнем с ножа.

1. Создадим файл `knife.dart` в котором укажем, что это часть библиотеки `game`.
2. Подключим его к библиотеке.
3. Объявим класс `Knife` и укажем, что он реализует интерфейс `WeaponBehavior`. 
4. Теперь реализуем единственный метод, который определен в `WeaponBehavior` - `useWeapon()`, в котором просто выведем в консоль надпись о том, что мы используем нож.

Вот и все. Класс для ножа готов. Классы для меча и топора имеют такую же структуру, только в методе `useWeapon()` они выводят в консоль, что используется меч или топор, соответственно. Поэтому, давайте тоже быстро создадим класс для меча (`Sword`) и топора (`Axe`). 