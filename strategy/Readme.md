# Стратегия

> Паттерн **стратегия** определяет семейство алгоритмов, инкапсулирует их и обеспечивает их взаимозаменяемость. Он позволяет модифицировать алгоритмы независимо от их использования на стороне клиента. 

Вот такое определение дается этому паттерну в книге "Паттерны проектирования".

Стратегия нужна тогда, когда нужно не просто спрятать алгоритм, а когда нам важно иметь возможность заменить его во время исполнения.

## Описание примера, на котором будем тренироваться

На словах, думаю, не совсем понятно то, как работает этот паттерн. Поэтому давайте разберем пример простого приложения.

Мы сделаем простое приложение, где будут персонажи (король, королева и тролль) и они будут драться с помощью оружия. 

В арсенале оружия у нас будет нож, меч и топор.

Каждый персонаж может владеть любым из этих оружий. И использовать его, чтобы драться.

![](http://storage9.static.itmages.com/i/14/1118/h_1416322069_9959895_dc4988faec.png)

### Подумаем о персонажах

Итак, давайте определимся, что умеют делать персонажи и что у них есть. У персонажей есть оружие (но его может и не быть). Персонаж может сказать кто он и нанести удар.

Также персонаж может менять свое оружие. Давайте быстро спроектируем абстрактный класс для персонажа.

![](http://storage8.static.itmages.com/i/14/1118/h_1416322688_9354164_cc8ac4c02b.png)

В `_weapon` у нас будет храниться оружие персонажа, а сеттер `weapon` будет отвечать за присвоение оружия персонажу.

В методе (который будет *абстрактным*) `say()` персонаж будет говорить, кто он такой, а в методе `fight()` - наносить удар.

Все три персонажа будут наследниками этого абстрактного класса. 

![](http://storage8.static.itmages.com/i/14/1118/h_1416323153_1928329_d16f43da2a.png)

### Подумаем об оружии

Персонажи могут менять оружие, поэтому, будет правильно, если мы определим общий интерфейс для работы с оружием. Назовем этот интерфейс `WeaponBehavior`. Наши персонажи могут только использовать оружие, поэтому интерфейс будет требовать реализации только одного метода - `useWeapon()`, который нужно будет реализовать каждому виду оружия.

Выделив общий интерфейс для оружия мы позволим достаточно просто реализовать замену оружия так, что нашим персонажам будет все равно, что они используют. Они будут просто вызывать метод `useWeapon()`.

Давайте взглянем на наш интерфейс оружия: 

![](http://storage6.static.itmages.com/i/14/1118/h_1416323871_2345869_73719bb66f.png) 

Классы ножа, меча и топора будут реализовывать этот интерфейс. В нашем случае, они просто будут содержать реализацию метода `useWeapon()`.

Вот как будет выглядеть связь:

![](http://storage5.static.itmages.com/i/14/1118/h_1416324163_6758001_13beaf8823.png)

### Что мы имеем

Сейчас мы спроектировали такую архитектуру, где персонаж знает о том, что в руках у него есть оружие, но какое именно оружие он не знает. Он знает, что его можно использовать. Как использовать конкретное оружие уже определяется в самом оружии. 

Такая архитектура позволяет без проблем создавать новое оружие и сразу же начинать его использовать. Вот как будет выглядеть архитектура в целом:

![](http://storage8.static.itmages.com/i/14/1118/h_1416324523_3562306_70a3b86fc0.png)

## Давайте начнем писать код

Первым делом создадим файл `pubspec.yaml`, в котором укажем имя нашего приложения (пусть это будет `game`):

```yaml
name: game
```

Создадим папку `bin`, а в ней файл `game.dart`, в котором пропишем пока что пустую функцию `main()`:

```dart
main() {
	
}
```

Теперь создадим папку `lib`, в которой будут находиться классы персонажей и оружия нашего приложения. Добавим в нее файл `game.dart`, в котором объявим библиотеку `game`.

```dart
library game;
```

### Создание оружия

Итак, базовую структуру мы сделали, давайте теперь перейдем к оружию.

Создадим внутри папке `lib`, папку `src/weapon`, в которой будет находиться интерфейс для определения поведения оружия и сами классы оружия.

В Dart классы являются одновременно и интерфейсами. Давайте создадим интерфейс `WeaponBehavior` (файл `lib/src/weapon/weapon_behavior.dart`).

```dart
part of game;

abstract class WeaponBehavior {

  void useWeapon();

}
```

В первой строке мы указали, что данный файл является частью библиотеки `game`, затем объявили абстрактный класс `WeaponBehavior` (который будем использовать как интерфейс), а в нем метод `useWeapon()`.

Все, интерфейс готов. Подключим его теперь к нашей библиотеке с помощью ключевого слова `part` в файле `lib/game.dart`.

```dart
library game;

part "src/weapon/weapon_behavior.dart";
```

*Во время разработки этой игры мы еще часто будем подключать файлы к библиотеке, но больше я описывать это не буду. Подключаются они с помощью ключевого слова `part`, как показано выше*.

Пора создать классы ножа, меча и топора. Начнем с ножа.

Создадим файл `lib/src/weapon/knife.dart` со следующим содержимым:

```dart
part of game;

class Knife implements WeaponBehavior {

  void useWeapon() {
    print("Использую нож");
  }

}
```

Здесь мы определили класс `Knife`, который реализует интерфейс `WeaponBehavior`. И реализовали метод `useWeapon()`, определенный этим интерфейсом. В данном методе мы просто выводим на консоль информацию о том, что используем нож. Также не забудем подключить данный файл к библиотеке в файле `lib/game.dart`

Классы для меча и топора имеют такую же структуру, только в методе `useWeapon()` они выводят в консоль, что используется меч или топор, соответственно. Я не буду приводить код данных классов, но его можно будет найти по [этой ссылке](example).

### Создание персонажей

Выше мы говорили об абстрактном классе `Character`, поэтому давайте с него и начнем.

`lib/src/characters/character.dart`:

```dart
part of game;

abstract class Character {

  WeaponBehavior _weapon;

  void set weapon(weapon) {
    _weapon = weapon;
  }

  void say();

  void fight() {
    if (_weapon != null) {
      _weapon.useWeapon();
    } else {
      print("Я безоружен");
    }
  }

}
```

Здесь мы объявили абстрактный класс `Character` с приватным свойством `_weapon`. Данное свойство относится к типу `WeaponBehavior`, чем мы говорим, что тот объект (без разницы, какой у него будет реальный тип), который хранится в этом свойстве, будет реализовывать интерфейс `WeaponBehavior`.

Также мы определили сеттер для оружия; абстрактный метод `say()`, в котором персонаж должен будет представиться; и метод `fight()`, где мы проверяем, есть ли у персонажа оружие - если есть, то используем его, а иначе выводим на консоль сообщение о том, что он безоружен.

Теперь можно реализовать классы для короля, королевы и тролля. Начнем с короля.

`lib/src/characters/king.dart`:

```dart
part of game;

class King extends Character {

  void say() {
    print("Я король");
  }

}
```

В коде выше мы объявили класс `King`, который является наследником `Character`, и реализовали абстрактный метод `say()`, определенный в `Caharacter`, в котором просто вывели на консоль сообщение `"Я король"`.

Классы королевы и тролля похожи на класс короля, только в методе `say()` они выводят сообщение о том, что королева это королева, а тролль это тролль. Я не буду приводить код этих классов, но его можно будет найти [здесь](example).

### Скрипт для запуска

Перед тем, как начать писать скрипт для запуска нужно из корня нашего проекта запустить команду `pub get`. Сделать это нужно для того, чтобы пакет нашего приложения был доступен через `package:game/game.dart` (файл `game.dart` в данном случае - это файл `lib/game.dart`). 

Откроем файл `bin/game.dart` и напишем в нем следующее:

```dart
import "package:game/game.dart";

void main() {

  King king = new King();
  Queen queen = new Queen();
  Troll troll = new Troll();

  // Представимся
  king.say();
  // Получим нож
  king.weapon = new Knife();
  // Ударим
  king.fight();

  // Представимся
  queen.say();
  // Получим топор
  queen.weapon = new Axe();
  // Ударим
  queen.fight();

  // Представимся
  troll.say();
  // Ударим
  troll.fight();
  // Получим меч
  troll.weapon = new Sword();
  // Ударим
  troll.fight();

}
```

Думаю, что по комментариям к коду понятно, что в нем происходит. Давайте запустим этот скрипт с помощью команды `dart bin/game.dart`, которую нужно выполнить из корня проекта. Вот что мы увидим в консоли:

```
Я король
Использую нож
Я королева
Использую топор
Я тролль
Я безоружен
Использую меч
```

Все как и ожидалось. Король представился и ударил ножом. Королева представилась и ударила топором. Тролль представися, попробовал ударить, но был безоружен, затем взял меч и ударил.

Давайте теперь изменим код так, что король после удара ножом возьмет меч и снова ударит. Добавьте эти строки после 14 строки предыдущего примера:

```dart
king.weapon = new Sword();
king.fight();
```

Снова запустим наш скрипт и увидим в консоли, что король после удара ножом ударил мечем:

```
Я король
Использую нож
Использую меч
Я королева
Использую топор
Я тролль
Я безоружен
Использую меч
```

## Итоги

Как было сказано в начале, паттерн “Стратегия” позволяет выделить семейство алгоритмов и спрятать их. В нашем примере мы выделили семейство алгоритмов, которые отвечают за работу с оружием, определили интерфейс для работы с ними и реализовали несколько классов оружия.

Благодаря тому, что мы выделили общий интерфейс для работы с оружием, нашим персонажам все равно, какое оружие они держат в руках. Для его использования они просто вызывают метод useWeapon(), который определен интерфейсом WeaponBehavior. И это нам позволяет менять оружие во время выполнения программы.

Также мы теперь можем очень просто создавать новое оружие и сразу же начинать его использовать.

Если вы хотите потренироваться или закрепить использование данного паттерна, то попробуйте добавить возможность перемещения персонажа разными способами (например, пешком, бегом, на коне, или сделать персонажа неподвижным).

[Код примера](example).