# Наблюдатель

Определение из Википедии:

> Паттерн **Наблюдатель** создает механизм у класса, который позволяет получать экземпляру объекта этого класса оповещения от других объектов об изменении их состояния, тем самым наблюдая за ними.

Если сказать простыми словами, то при реализации паттерна **"Наблюдатель"** у нас есть объект (его называют *издателем* или *субъектом*), за изменением состояния которого может наблюдать переменное число других объектов (их называют *наблюдателями* или *подписчиками*).

Можно привести массу примеров из реальной жизни, где используется паттерн **"Наблюдатель"**. Думаю, что все знают, как обрабатывать различные события текстового поля. Нажатие клавиши, отпускание клавиши и так далее. В этом случае - текстовое поле будет *субъектом*, а обработчики, которые реагируют на различные события - *наблюдателями*.

## Опиание приложения

Разберем для ясности простой пример использования паттерна "Наблюдатель". Сделаем приложение, в котором будет **издатель**, выпускающий газету, и **читатели**. Когда издатель выпустит новый номер газеты, то все читатели должны будут его получить. Если читатель отпишется от получения, то газеты ему доставляться не будут.

![](http://storage7.static.itmages.com/i/14/1222/h_1419279095_9090167_1bfbe5af01.png)

У **издателя** будет приватное свойство `_pubCtrl` типа `StreamController`. Публичное свойство `onPub` класса `Stream`, через которое будет осуществляться подписка. 

Здесь я хочу сделать небольшое отступление. В Dart есть несколько путей для реализации паттерна **Наблюдатель**. Например, его можно реализовать с помощью пакета [observable](https://pub.dartlang.org/packages/observe), либо с помощью потоков. В нашем примере мы рассмотрим реализацию с помощью потоков.

Также у **издателя** будет метод `publish()`, принимающий на вход объект газеты - этот метод будет отвечать за *выпуск* газеты. 

У **газеты** мы будем знать только ее номер (`number`) и заголовок на первой полосе (`firstLine`).

![](http://storage9.static.itmages.com/i/14/1222/h_1419280210_8580232_b57f643d87.png)

У **читателя** будет имя (`name`) и метод `read()`, принимающий на вход газету.

![](http://storage6.static.itmages.com/i/14/1222/h_1419283169_7989755_bd05e316c7.png)

## Начнем писать код

Первым делом создадим `pubspec.yaml` в котором укажем имя нашего приложения:

```yaml
name: paper
```

Создадим папку `bin`, а в ней файл `main.dart` с пустой функцией `main()`:

```dart
main() {
	
}
```

Создадим папку `lib`, в которой бдует находиться библиотека нашего приложения. В файле `lib/paper.dart` объями библиотеку `paper`:

```dart
library paper;
```

### Класс газеты

Создадим папку `src` в директории `lib`. В ней (`lib/src`) сделаем файл `paper.dart` с объявлением класса газеты:

```dart
part of paper;

class Paper {

  int number;
  String firstLine;

  Paper(this.number, this.firstLine);

}
```

В первой строке указано, что данный файл (`lib/src/paper.dart`) является частью библиотеки `paper`. Затем мы объявили класс, два свойства - `number` (номер газеты) и `firstLine` (заголовок на первой строке). Также сделали конструктор, через который можно будет установить значения этим свойствам при создании газеты.

После этого нужно подключить файл `lib/src/paper.dart` к библиотеке. Сделать это можно с помощью ключевого слова `part` в файле, где объявлена библиотека (`lib/paper.dart`):

```dart
library paper;

part "src/paper.dart";
```
> **Примечание** 
>
> Дальше мы создадим еще файлы для нашей библиотеки. Их нужно будет так же, как и сейчас, подключить к библиотеке.

### Класс читателя

Создадим файл `lib/src/reader.dart` со следующим содержимым:

```dart
part of paper;

class Reader {

  String name;

  Reader(this.name);

  void read(Paper paper) {
    print("Я $name. Получил газету #${paper.number} с заголовком \"${paper.firstLine}\"");
  }

}
```

В этом файле мы объявили класс `Reader`, указали у него свойство `name` и конструктор, через который можно будет установить значение этому свойству. Объявили функцию `read(Paper paper)`, принимающую на вход объект класса `Paper`. В ней читатель просто говорит, кто он такой и что прочитал.

### Класс издателя

Создадим файл `lib/src/publisher.dart` со следующим содержимым:

```dart
part of paper;

class Publisher {

  StreamController<Paper> _pubCtrl = new StreamController<Paper>(sync: true);
  Stream<Paper> onPub;

  Publisher() {
    onPub = _pubCtrl.stream.asBroadcastStream();
  }

  void publish(Paper paper) {
    _pubCtrl.add(paper);
  }

}
```

В этом файле мы объявили класс `Publisher`.

В пятой строке объявили свойство `_pubCtrl`, класса `StreamContrller`. В треугольных скобочках указали класс объектов, с которыми будет работать контроллер. Это делать не обязательно. В конструкторе потока мы указали именованный параметр `sync` со значением `true`. Это мы сделали для того, чтобы сделать поток синхронным, благодаря чему сообщения слушателям будут доставляться сразу же.

На шестой строке объявили свойство `onPub` класса `Stream`, которое инициализируем в конструкторе на 9 строке. Для этого мы обращаемся к свойству `stream` у `_pubCtrl`. И для того, чтобы с этим потоком могло работать несколько подписчиков вызываем метод `asBroadcastStream()`. 

На двенадцатой строке объявляем метод `publish(Paper paper)`, который принимает в качестве параметра объект газеты. Внутри этого метода мы добавляем газету в контроллер потока.

### Связываем все воедино

Пора связать все, что мы написли, воедино. Но сперва выполним команду `pub get` из корня проекта. Сделаем это для того, чтобы библиотеку нашего приложения можно было импортировать через `package:paper/paper.dart`.

Изменим содержимое файла `bin/main.dart` на следующее:

```dart
import "package:paper/paper.dart";

main() {

  Publisher publisher = new Publisher();

  Reader fedor = new Reader("Федор");
  Reader emelya = new Reader("Емеля");
  Reader ruslan = new Reader("Руслан");

  publisher.onPub.listen(fedor.read);
  var emelyaSub = publisher.onPub.listen(emelya.read);
  publisher.onPub.listen(ruslan.read);

  Paper one = new Paper(1, "Первая газета нашего издательства");
  publisher.publish(one);

  emelyaSub.cancel();

  Paper two = new Paper(2, "Вторая газета");
  publisher.publish(two);
}
```

В первой строке мы подключили библиотеку нашего приложения. Затем, в пятой строке создали издателя. В строках 7, 8, 9 создали трех читателей - Федора, Емелю и Руслана. В строках 11, 12 и 13 подписали их на поток `onPub`, в который будут попадать газеты во время публикации. 

Подписка на поток осуществляется с помощью метода `listen`, в который передается функция-обработчик. Она будет вызвана тогда, когда в потоке появятся данные.

Также, в 12 строке мы сохранили объект, который возвращает метод подписки на поток - `listen`. Метод `listen` возвращает объект класса `StreamSubsription`. С помощью этого объекта можно получить доступ к обработчикам различных событий потока, приостановить его прослушку, снова запустить, либо полностью отписаться. Для того, чтобы отписаться от получения данных, нужно воспользоваться методом `cancel()`. 

В 15 строке мы выпустили первую газету, а в 16 - опубликовали ее.

В строке 18 с помощью метода `cancel`, объекта, который вернул `listen` при подписке Емели на получение газеты, мы отписали его. 

Затем, в 20 строке выпустили второй номер газеты, а в 21 - опубликовли его.

Итак, мы создали издатели трех подписчиков (Федора, Руслана и Емелю). Подписали их на выпуски газеты и сделали первую публикацию. Затем отписали Емелю и сделали вторую публикацию. При запуске нашего скрипта мы должны увидеть, что сначала все три читателя полуичли газету, а затем только два - Федор и Руслан. Запустим пример командой `dart bin/main.dart` из корня проекта и увдим в консоли такой вывод:

```
Я Федор. Получил газету #1 с заголовком "Первая газета нашего издательства"
Я Емеля. Получил газету #1 с заголовком "Первая газета нашего издательства"
Я Руслан. Получил газету #1 с заголовком "Первая газета нашего издательства"
Я Федор. Получил газету #2 с заголовком "Вторая газета"
Я Руслан. Получил газету #2 с заголовком "Вторая газета"
```

Все отлично. Этого мы и ожидали.

[Код примера](example)